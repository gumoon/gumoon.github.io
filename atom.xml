<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[自由学习网]]></title>
  <link href="http://www.free-abc.com.cn/atom.xml" rel="self"/>
  <link href="http://www.free-abc.com.cn/"/>
  <updated>2016-11-23T18:10:02+08:00</updated>
  <id>http://www.free-abc.com.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[saltstack实践]]></title>
    <link href="http://www.free-abc.com.cn/14798983960110.html"/>
    <updated>2016-11-23T18:53:16+08:00</updated>
    <id>http://www.free-abc.com.cn/14798983960110.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">解决什么需求？</a>
</li>
<li>
<a href="#toc_1">解决方案</a>
</li>
<li>
<a href="#toc_2">介绍</a>
</li>
<li>
<a href="#toc_3">安装</a>
</li>
<li>
<a href="#toc_4">master配置</a>
</li>
<li>
<a href="#toc_5">minion配置</a>
</li>
<li>
<a href="#toc_6">salt常用命令</a>
<ul>
<li>
<a href="#toc_7">命令帮助文档</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">普通用户执行salt</a>
</li>
<li>
<a href="#toc_9">target</a>
</li>
<li>
<a href="#toc_10">pkg</a>
</li>
<li>
<a href="#toc_11">service</a>
</li>
<li>
<a href="#toc_12">使用状态文件同步状态</a>
</li>
</ul>


<h2 id="toc_0">解决什么需求？</h2>

<ul>
<li>配置文件可以统一通过版本管理平台进行管理</li>
<li>配置文件可以迅速统一对所有机器进行一致性配置</li>
<li>配置管理和远程执行</li>
</ul>

<h2 id="toc_1">解决方案</h2>

<table>
<thead>
<tr>
<th style="text-align: left">需求</th>
<th style="text-align: right">解决方案</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">操作系统和软件的安装、配置、初始化等；</td>
<td style="text-align: right">Puppet, Chef, CFEngine, AnsibleWorks, SaltStack</td>
</tr>
<tr>
<td style="text-align: left">自动执行任务，比如定期备份、清除日志等；</td>
<td style="text-align: right">Fabric, AnsibleWorks, SaltStack</td>
</tr>
<tr>
<td style="text-align: left">手动执行任务，比如部署应用、升级、重启、检查和校验文件系统、增加用户等。</td>
<td style="text-align: right">Fabric, Rake, AnsibleWorks, SaltStack</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">介绍</h2>

<ul>
<li><a href="http://www.saltstack.cn">http://www.saltstack.cn</a> </li>
<li><a href="http://saltstack.com">http://saltstack.com</a></li>
<li>saltstack 采用 zeromq 消息队列进行通信，和 Puppet/Chef 比起来，saltstack 速度快得多。minion与master之间通过ZeroMQ消息队列通信。</li>
<li>saltstack 是用 python 语言编写的批量管理工具，完全开源，遵守Apache2协议。</li>
<li>saltstack 需要在一台机器（主控）上安装服务器软件（SaltStack 称之为 salt master），在多台机器（受控）上安装客户端软件（SaltStack 称之为 salt minion）。在主控机器上给下属（受控）发命令，在受控机器上接受和执行上级（主控）的命令。</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: left">名称</th>
<th style="text-align: center">功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Master</td>
<td style="text-align: center">控制中心，salt命令运行和资源状态管理端</td>
</tr>
<tr>
<td style="text-align: left">Minion</td>
<td style="text-align: center">需要管理的客户端机器，会主动去连接master端，并从master端得到资源状态信息，同步资源管理信息</td>
</tr>
<tr>
<td style="text-align: left">State</td>
<td style="text-align: center">配置管理的指令集</td>
</tr>
<tr>
<td style="text-align: left">Module</td>
<td style="text-align: center">包含命令行下运行的命令和在配置文件里面使用的命令；模块的函数可以在命令行下运行</td>
</tr>
<tr>
<td style="text-align: left">Grains</td>
<td style="text-align: center">Minion端的变量，静态的</td>
</tr>
<tr>
<td style="text-align: left">Pillar</td>
<td style="text-align: center">Minion端的变量，动态的</td>
</tr>
<tr>
<td style="text-align: left">highstate</td>
<td style="text-align: center">给 minion 永久添加状态，从sls配置文件读取到的，即同步状态配置</td>
</tr>
<tr>
<td style="text-align: left">salt schedule</td>
<td style="text-align: center">自动保持客户端配置</td>
</tr>
</tbody>
</table>

<p>命令执行具体步骤：<br/>
1. Salt stack的Master与Minion之间通过ZeroMQ进行消息传递，使用了ZeroMQ的发布-订阅模式，连接方式包括tcp、ipc<br/>
2. salt命令，将 <code>cmd.run ls</code> 命令从 <code>salt.client.LocalClient.cmd_cli</code> 发布到master，获取一个 Jobid，根据jobid获取命令执行结果。<br/>
3. master接收到命令后，将要执行的命令发送到客户端minion。<br/>
4. minion从消息总线上接收到要处理的命令，交给 <code>minion._handle_aes</code> 处理。<br/>
5. <code>minion._handle_aes</code> 发起一个本地线程调用cmd mod 执行ls命令。线程执行完ls后，调用 <code>minion._return_pub</code> 方法，将执行结果通过消息总线返回给master<br/>
6. master接收到客户端返回的结果，调用 <code>master._handle_aes</code> 方法，将结果写到文件中<br/>
7. <code>salt.client.LocalClient.cmd_cli</code> 通过轮询获取job执行结果，将结果输出到终端。</p>

<h2 id="toc_3">安装</h2>

<p>需要先安装 epel 库。</p>

<p><code>yun install salt-master.noarch salt-minion.noarch</code></p>

<p>配置开机启动&amp;并且启动：</p>

<pre><code>systemctl enable salt-master.service 
systemctl start salt-master.service
systemctl enable salt-minion.service
systemctl start salt-minion.service
</code></pre>

<p>打开防火墙：</p>

<pre><code>firewall-cmd --zone=public --add-port=4505/tcp --permanent
firewall-cmd --zone=public --add-port=4506/tcp --permanent
firewall-cmd --reload
</code></pre>

<pre><code>➜  salt  yum list installed |grep salt
salt.noarch                           2015.5.5-1.el7                   @epel
salt-master.noarch                    2015.5.5-1.el7                   @epel
salt-minion.noarch                    2015.5.5-1.el7                   @epel
</code></pre>

<h2 id="toc_4">master配置</h2>

<p>将日志配置得更详细点，以便日后排除故障。</p>

<pre><code>log_level: debug
log_level_logfile: debug
</code></pre>

<p>和 puppet 一样， salt 的 master 和 minions 是通过证书通信的，故存在证书的信任颁发问题。<br/>
认证 minion:</p>

<pre><code>salt-key -L   （在master上执行，查看当前需要接受的 keys ，master 和 minions 都需要把服务开启）
salt-key -a 1st-salt-minion（minionID）（请求加入受控的minion id）
</code></pre>

<p>master下发任务匹配到的minion上去，minion执行模块函数，并返回结果。master监听4505和4506端口，4505对应的是ZMQ的PUB system，用来发送消息，4506对应的是REP system是来接受消息的。</p>

<p>若 master 启动失败，请运行 salt-master 来排错。</p>

<p>这两个端口的监听是python程序。</p>

<h2 id="toc_5">minion配置</h2>

<p><code>vim /etc/salt/minion</code><br/>
配置master: 127.0.0.1 、id: 1st-salt-minion</p>

<p>原理：<br/>
在启动时，下属客户机会生成一个密钥和一个id。然后，它会连接到salt领主服务器并验证自己的身份。salt领主服务器在允许下属客户机下载配置前，必须接受下属的密钥。</p>

<p>master可以发送任何指令让minion执行。salt有很多可执行模块，比如 cmd模块，在安装minion的时候已经自带了。它们通常位于你的python库中，<code>locate salt | grep /usr/</code> 可以看到salt自带的所有东西。</p>

<p>若minion启动失败，请运行：salt-minion 命令来排错。<br/>
更改 master 后，重启 minion h</p>

<p>不需要监听特殊的端口。但是有tcp连接。可以通过 netstat -t 来，原因是：minion主动连接master</p>

<h2 id="toc_6">salt常用命令</h2>

<ul>
<li>salt 该命令执行salt的执行模块，通常在master端执行。也是我们最常用到的命令</li>
</ul>

<pre><code>salt [options] &#39;&lt;target&gt;&#39; &lt;function&gt; [arguments] 
salt &#39;*&#39; test.ping
salt &#39;*&#39; cmd.run &quot;uptime&quot;
salt &#39;*&#39; cmd.run &#39;ls -l&#39;
salt -G &#39;os:Centos&#39; test.ping  ##salt使用一个名为颗粒（Grains）的界面来获取系统信息。你可以使用颗粒在指定属性的系统上运行命令。
</code></pre>

<ul>
<li>salt-run 该命令执行runner(salt带的或者自定义的，runner以后会讲)，通常在master端执行，比如经常用到的manage</li>
</ul>

<pre><code>salt-run [options] [runner.func]
salt-run manage.status   ##查看所有minion状态
salt-run manage.down   ##查看所有没在线的minion
salt-run manage.up     ##查看所有在线的minion
</code></pre>

<ul>
<li>salt-key 密钥管理，通常在master端执行</li>
</ul>

<pre><code>salt-key [options]
salt-key -L ##查看所有minion-key
salt-key -a &lt;key-name&gt; ##接受某个minion-key
salt-key -d &lt;key-name&gt; ##删除某个minion-key
salt-key -A ##接受所有的minion-key
salt-key -D ##删除所有的minon-key
</code></pre>

<ul>
<li>salt-call 该命令通常在minion上执行，minion自己执行可执行模块，不是通过master下发job</li>
</ul>

<pre><code>salt-call [options] &lt;function&gt; [arguments]
salt-call test.ping ##自己执行test.ping命令
salt-call cmd.run &#39;ifconfig&#39; ##自己执行cmd.run函数
salt-call state.sls production/default/vim
</code></pre>

<ul>
<li>salt-cp 分发文件到minion上，不支持目录分发，通常在master运行</li>
</ul>

<pre><code>salt-cp [options] &#39;&lt;target&gt;&#39; SOURCE DEST
salt-cp &#39;*&#39; testfile.html /tmp
salt-cp &#39;test&#39; index.html /tmp/a.html 
</code></pre>

<ul>
<li>salt-ssh</li>
<li>salt-master master运行命令</li>
</ul>

<pre><code>salt-master [options]
salt-master ##前台运行master
salt-master -d ## 后台运行master
salt-master -i debug ##前台debug输出
</code></pre>

<ul>
<li>salt-minion minion运行命令</li>
</ul>

<pre><code>salt-minion [options]
salt-minion ##前台运行minion
salt-minion -d ## 后台运行minion
salt-minion -i debug ##前台debug输出
</code></pre>

<ul>
<li>salt-syndic syndic是salt的代理。</li>
</ul>

<h3 id="toc_7">命令帮助文档</h3>

<pre><code>salt &#39;*&#39; sys.doc ##查看所有执行模块的帮助
salt &#39;*&#39; sys.doc test ##查看test模块的帮助
salt &#39;*&#39; sys.doc test.ping ##查看test模块ping函数的帮助
</code></pre>

<h2 id="toc_8">普通用户执行salt</h2>

<p>默认root用户具有执行salt权限。<br/>
普通用户执行salt两种方案：</p>

<ul>
<li>salt ACL </li>
<li>salt external_auth</li>
</ul>

<h2 id="toc_9">target</h2>

<p>指定你的命令或者模块应用在哪个minion上。</p>

<ul>
<li>globbing 默认</li>
</ul>

<pre><code>salt &#39;test*&#39; test.ping
</code></pre>

<ul>
<li>RE 正则</li>
</ul>

<pre><code>salt -E &#39;web1-(pro|devel)&#39; test.ping
</code></pre>

<ul>
<li>List列表</li>
</ul>

<pre><code>salt -L &#39;127.0.0.1, test*&#39; test.ping 
</code></pre>

<ul>
<li>grains（谷物）
<a href="http://docs.saltstack.cn/zh_CN/latest/topics/targeting/grains.html">http://docs.saltstack.cn/zh_CN/latest/topics/targeting/grains.html</a>
<strong>grains是minion启动时加载的，在运行过程中不会发生变化，所以是静态数据。grains中包含诸如运行的内核版本，操作系统等信息。</strong>
grains这个跟puppet的facter功能一样。主要负责采集客户端一些基本信息，这个也完全可以自定义，可以在客户端自定义，然后自动汇报上来；也可以从服务器端定义然后推下去，采集完后，再汇报上来。pillar 跟 grains 比较的话，他的灵活性强点，想怎么定义就怎么定义，然后取值就行。</li>
</ul>

<pre><code>salt -G &#39;os:CentOS&#39; test.ping
salt &#39;test*&#39; grains.items #查看所有grains键值
salt &#39;test*&#39; grains.ls #查看所有grains项
salt &#39;test*&#39; grains.item num_cpus #查看某个grains的值
</code></pre>

<p>可以给每个 minion 配置自定义的 grains ，方便系统管理员管理。</p>

<ul>
<li>组
编辑配置文件 /etc/salt/master </li>
</ul>

<pre><code>nodegroups:
  webserver: &#39;L@bj_123.56.204.140,hk_58.96.169.47&#39;
  testserver: &#39;bj_182.92.101.72&#39;
</code></pre>

<p>之后重启 master 。<br/>
测试：</p>

<pre><code> salt -N webserver test.ping
 salt -N testserver test.ping
</code></pre>

<p>关于组的混合匹配：(Compound matchers)</p>

<table>
<thead>
<tr>
<th style="text-align: left">Letter</th>
<th style="text-align: center">含义</th>
<th style="text-align: right">例子</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">G</td>
<td style="text-align: center">Grains glob匹配</td>
<td style="text-align: right">G@os:Ubuntu</td>
</tr>
<tr>
<td style="text-align: left">E</td>
<td style="text-align: center">PCRE Minon id匹配</td>
<td style="text-align: right">E@web\d+.(dev|qa|prod).loc</td>
</tr>
<tr>
<td style="text-align: left">P</td>
<td style="text-align: center">Grains PCRE匹配</td>
<td style="text-align: right">P@os:(Redhat|Fedora|CentOS)</td>
</tr>
<tr>
<td style="text-align: left">L</td>
<td style="text-align: center">minions列表</td>
<td style="text-align: right"><a href="mailto:L@minion1.example.com">L@minion1.example.com</a>,minion3.domain.com or bl*.domain.com</td>
</tr>
<tr>
<td style="text-align: left">I</td>
<td style="text-align: center">Pillar glob匹配</td>
<td style="text-align: right">I@pdata:foobar</td>
</tr>
<tr>
<td style="text-align: left">S</td>
<td style="text-align: center">子网、IP地址匹配</td>
<td style="text-align: right">S@192.168.1.0/24 or S@192.168.1.100</td>
</tr>
<tr>
<td style="text-align: left">R</td>
<td style="text-align: center">Range cluster匹配</td>
<td style="text-align: right">R@%foo.bar</td>
</tr>
<tr>
<td style="text-align: left">D</td>
<td style="text-align: center">Minion Data匹配</td>
<td style="text-align: right">D@key:value</td>
</tr>
</tbody>
</table>

<ul>
<li>pillar
Pillar 是 Salt 非常重要的一个组件，它用于给特定的 minion 定义任何你需要的数据， 这些数据可以被 Salt 的其他组件使用。Salt 在 0.9.8 版本中引入了 Pillar。Pillar 在解析完成 后，是一个嵌套的 dict 结构；最上层的 key 是 minion ID，其 value 是该 minion 所拥有的 Pillar 数据；每一个 value 也都是 key/value。这里可以看出 Pillar 的一个特点，Pillar 数据是与特定 minion 关联的，也就是说每一个minion 都只能看到自己的数据， 所以 Pillar 可以用来传递敏感数据 （在 Salt 的设计中， Pillar 使用独立的加密 session，也是为了保证敏感数据的安全性）</li>
</ul>

<p>Pillar 可以用在哪些地方？</p>

<p><strong>敏感数据</strong><br/>
例如 ssh key，加密证书等，由于 Pillar 使用独立的加密 session，可以确保这些敏感数据不被其他 minion 看到。</p>

<p><strong>变量</strong><br/>
可以在 Pillar 中处理平台差异性，比如针对不同的操作系统设置软件包的名字，然后在State 中引用。 </p>

<p><strong>其他任何数据</strong><br/>
可以在 Pillar 中添加任何需要用到的数据。比如定义用户和 UID 的对应关系，mnion 的角色等。 </p>

<p><strong>用在 Targetting 中</strong><br/>
Pillar 可以用来选择 minion，使用-I 选项<br/>
默认情况下，master 配置文件中的所有数据都添加到 Pillar 中，且对所有 minion 可用。如果要禁用这一默认值，可以在 master 配置文件中添加如下数据，重启服务后生效<strong>？？？此处存疑。好像默认没有添加master配置文件中的数据到 pillar 中。</strong></p>

<h2 id="toc_10">pkg</h2>

<p>saltstack安装包管理。<br/>
<code>salt &#39;*&#39; pkg.install tree</code></p>

<h2 id="toc_11">service</h2>

<p>saltstack服务管理。</p>

<h2 id="toc_12">使用状态文件同步状态</h2>

<p>类似于puppet的pp文件功能，salt的state文件扩展名为.sls，采用的和puppet一样的设计思路，即服务器最终应该具有的一些状态，比如应该安装有什么软件包？哪些服务应该保持运行或者开机自启动？哪些配置文件需要保持同步？等等。这样用户无需关心这个过程究竟是怎样的，只需要描述最终状态即可，即使运行失败，saltstack也会返回一个友好的错误信息，提示用户应该如何处理。<br/>
* salt默认的根目录在 /srv/salt 中，没有这个目录需要建立一个。<br/>
* saltstack的sls状态文件采用的是yaml模板和jinja2模板，编写的时候注意格式，注意缩排和空格。<br/>
* <code>salt &#39;*&#39; state.sls production/default/vim</code><br/>
* 执行完上面的命令，salt帮我们成功的安装好了vim-enhanced这个软件包，接下来我们只需要同步一下vim的配置文件，那么每台新部署的服务器都会有一个友好的vim可供使用。今后发现有更好的vim配置，也无需一个个scp到服务器上，仅仅只需要执行一下状态同步就可以了。<br/>
* top.sls：这个文件类似于puppet的site.pp文件，作为“最高同步”操作的入口文件，执行”最高同步”操作时，将从此sls文件中获取状态对minion进行同步。</p>

<p>salt state 主要用来描述系统、软件、服务、配置文件应该处于的状态，常常被称为配置管理！！！</p>

<p>sls 遵从 YAML 规范，它使用两个空格代替tab，：或 - 后面要有空格。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浏览器缓存机制]]></title>
    <link href="http://www.free-abc.com.cn/14798980187717.html"/>
    <updated>2016-11-23T18:46:58+08:00</updated>
    <id>http://www.free-abc.com.cn/14798980187717.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Expires和Last-Modified的区别</h2>

<p>资源在浏览器端的本地缓存可以通过Expires和Last-Modified返回头信息进行有效控制。</p>

<ol>
<li><p>Expires告诉浏览器在该指定过期时间前再次访问同一URL时，直接从本地缓存读取，无需再向服务器发起http请求；<br/>
优点是：浏览器直接读取缓存信息无需发起http请求。<br/>
缺点是：当用户按F5或Ctl+F5刷新页面时浏览器会再次发起http请求。</p></li>
<li><p>当服务器返回设置了Last-Modified头，下次发起同一URL的请求时，请求头会自动包含If-Modified-Since头信息，服务器对静态内容会根据该信息跟文件的最后修改时间做比较，如果最后修改时间不大于If-Modified-Since头信息，则返回304。告诉浏览器请求内容未更新可直接使用本地缓存。（注意：只对静态内容有效，如js/css/image/html等，不包括动态内容，如PHP）<br/>
优点：无论用户行为如何都有效；<br/>
缺点：仍需向服务器发起一次http请求；<br/>
现在webserver默认都会响应 Last-Modified 头。</p></li>
</ol>

<h2 id="toc_1">safari浏览器行为</h2>

<ol>
<li>地址栏回车（使用本地缓存，没有请求）</li>
<li>地址栏边上的刷新按钮（等价于F5）</li>
<li>command-R （等价于F5)</li>
<li>command-Shift-R 强制刷新（等价于 Ctrl-F5)</li>
</ol>

<h2 id="toc_2">ctrl-f5 与 f5 与 enter 刷新的区别</h2>

<p><strong>url地址栏里敲击enter：</strong><br/>
这样的刷新，大家可以在firebug里看一下，只有少数的请求会发送出去，而且几乎没有图片的请求，这是因为请求时会先检查本地是不是缓存了请求的图片，如果有缓存而且没有过期（过期可以通过该图片请求的header查看），他就不会发出这个图片request。_如果本地的图片已经过期，会带上If-Modified-Since请求头，去webserver请求，会产生访问日志。_</p>

<p><strong>f5：</strong><br/>
f5刷新比enter略慢，为什么呢，因为他还是把所有请求都发给了server，只是在request里的header里有信息<br/>
Expires Fri, 28 Jun 2013 07:29:55 GMT<br/>
Last-Modified   Mon, 21 Mar 2011 09:26:23 GMT<br/>
服务器判断还没有过期，就直接返回304not modified，在firebug里看就是这些304的请求都为灰色。因为直接返回304这样的信息，而不是图片等内容，他比ctrl+f5快，但是比enter慢，因为他还是把所有请求都发了一遍，比enter的不发请求自然是慢的。</p>

<p><strong>ctrl+f5：</strong><br/>
这个就要慢了，因为所有的请求都是重新发送，重新从server读取内容，一点cache都没有读。为了防止在server的cache里读取，在ctrl+f5刷新时，request的header里还加了特殊字段，这个大家可以用firebug看一下，还挺有意思的。在request header 里会加pragma：no-cache（_Pragma行是为了兼容HTTP1.0，作用与 Cache-Control: no-cache是一样的_）   cache control：no-cache。这两个就是告诉服务器到浏览器中间的所有节点，没有cache，看到这个中间节点也不查自己的cache，保证请求都是从server获得的。</p>

<h2 id="toc_3">注意事项</h2>

<ol>
<li>对于cdn的资源，即使强制刷新，也不过是读取到cdn的最新资源。</li>
<li>如果本地要更新到源站的资料，只能通过修改版本号，从而改变请求url，造成本地和cdn都没有，从而，去源站获取最新的。</li>
<li>静态资源务必都弄到cdn上去。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[YSlow性能优化指导]]></title>
    <link href="http://www.free-abc.com.cn/14798974234237.html"/>
    <updated>2016-11-23T18:37:03+08:00</updated>
    <id>http://www.free-abc.com.cn/14798974234237.html</id>
    <content type="html"><![CDATA[
<ol>
<li>favicon 的大小要小于2k。因为会从服务器根目录读，所以，要减小root下的 cookie 大小，并且让 favicon.ico 可缓存。</li>
<li>不是使用html的标签属性来 scale 图片。这样你可以避免从服务器加载一个更大的图片。</li>
<li>避免 AlphaImageLoader 过滤。它会增加内存消耗。</li>
<li>加载静态资源的域，避免带 cookie.</li>
<li>cookie 要尽量小。</li>
<li>减少dom元素。增加浏览器解析速度。</li>
<li>ajax 请求尽量使用get方式。因为 post 方式请求是，header和data分开发送，而get方式，header和data一起发送。但是，ie的最大url长度是2k，如果大于2k的数据，应该使用post。</li>
<li>确保 ajax 请求回来的数据可以缓存。</li>
<li>配置 etags ，增加缓存机会。</li>
<li>避免重复的js和css文件，它非常消耗性能。重复的js文件，ie和firefox会请求多次。</li>
<li>避免url重定向。</li>
<li>最小化js和css。减少字节数，减少加载时间。</li>
<li>别使用太多域名，减少 dns lookups 次数。</li>
<li>别把js和css写在html里面。通过外部引用的方式加载js和css。</li>
<li>避免css计算。</li>
<li>把js引用放在页面底部。因为js加载的时候，会禁止并行加载，浏览器就不能加载其他内容了。</li>
<li>把css引用放在页面顶部。css越早加载，页面越早展现。</li>
<li>服务器使用gzip压缩。gzip能压缩70%。</li>
<li>给 images , js ,css , flash  增加 expires 头。使它们变得<strong>可缓存</strong>。</li>
<li>避免空 src 和 href 。因为不同浏览器会有不同的默认行为，针对空地址。</li>
<li>使用cdn分发网络，提供静态自己加载速度。</li>
<li>减少http请求。合并文件，合并多个脚本文件到一个脚本文件，合并多个css文件到一个css文件，使用 css sprites 和 image maps.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从零开始配置阿里云ECS]]></title>
    <link href="http://www.free-abc.com.cn/14798739132293.html"/>
    <updated>2016-11-23T12:05:13+08:00</updated>
    <id>http://www.free-abc.com.cn/14798739132293.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">装完centos7.0 64位系统后的状态</h2>

<ol>
<li>默认操作系统情况</li>
</ol>

<pre><code>[root@iZ25gxj8d82Z etc]# uname -a
Linux iZ25gxj8d82Z 3.10.0-123.9.3.el7.x86_64 #1 SMP Thu Nov 6 15:06:03 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>

<ol>
<li>开启的对外端口情况</li>
</ol>

<pre><code>[root@iZ25gxj8d82Z ~]# ss -ntlp
State      Recv-Q Send-Q                                                                                       Local Address:Port                                                                                         Peer Address:Port
LISTEN     0      128                                                                                                      *:22                                                                                                      *:*      users:((&quot;sshd&quot;,895,3))
</code></pre>

<p>只开放了22端口。</p>

<ol>
<li>检查默认开机启动应用</li>
</ol>

<pre><code>[root@iZ25gxj8d82Z ~]# systemctl list-unit-files |grep enable
crond.service                          enabled
cups.service                           enabled
dmraid-activation.service              enabled
getty@.service                         enabled
lvm2-monitor.service                   enabled
microcode.service                      enabled
nscd.service                           enabled
ntpd.service                           enabled
rsyslog.service                        enabled
sshd.service                           enabled
sysstat.service                        enabled
systemd-readahead-collect.service      enabled
systemd-readahead-drop.service         enabled
systemd-readahead-replay.service       enabled
cups.socket                            enabled
dm-event.socket                        enabled
lvm2-lvmetad.socket                    enabled
nscd.socket                            enabled
default.target                         enabled
multi-user.target                      enabled
</code></pre>

<ol>
<li>默认用户情况</li>
</ol>

<pre><code>[root@iZ25gxj8d82Z ~]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
polkitd:x:999:998:User for polkitd:/:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
avahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologin
libstoragemgmt:x:998:997:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin
ntp:x:38:38::/etc/ntp:/sbin/nologin
abrt:x:173:173::/etc/abrt:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
chrony:x:997:996::/var/lib/chrony:/sbin/nologin
nscd:x:28:28:NSCD Daemon:/:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
</code></pre>

<p>以下都可以通过 saltstack 这个工具来实现：</p>

<h2 id="toc_1">更新系统</h2>

<p>查看目前有哪些源：</p>

<pre><code>yum repolist all 
</code></pre>

<p>替换官方centos源为阿里云源镜像。</p>

<ul>
<li>备份： </li>
</ul>

<pre><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
</code></pre>

<ul>
<li>下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ （此处使用阿里云源站内网域名，不占用公网流量）</li>
</ul>

<pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyuncs.com/repo/Centos-7.repo
</code></pre>

<ul>
<li>之后运行以下命令，生成缓存</li>
</ul>

<pre><code>yum makecache
</code></pre>

<ul>
<li>更新系统软件：</li>
</ul>

<pre><code>yum update
</code></pre>

<h2 id="toc_2">打开防火墙，并设置开机自启动</h2>

<pre><code>systemctl enable firewalld.service 
systemctl start firewalld.service
</code></pre>

<h2 id="toc_3">安装 zsh , oh-my-zsh</h2>

<ul>
<li>安装 zsh，配置 zsh 为root用户默认shell。 </li>
</ul>

<pre><code>yum install zsh 
which zsh (/usr/bin/zsh) 
vim /etc/shells 在文件末尾增加一行 /usr/bin/zsh 
chsh -s SHELL
</code></pre>

<ul>
<li>安装 oh-my-zsh </li>
</ul>

<pre><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>

<ul>
<li>安装 autojump:</li>
</ul>

<pre><code>yum install autojump-zsh
</code></pre>

<ul>
<li>配置 .zshrc ：</li>
</ul>

<pre><code>plugins=(git history autojump)
</code></pre>

<h2 id="toc_4">确认git，svn安装情况</h2>

<pre><code>git --version
svn --version
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis 安全]]></title>
    <link href="http://www.free-abc.com.cn/redis-safe.html"/>
    <updated>2016-11-23T11:44:23+08:00</updated>
    <id>http://www.free-abc.com.cn/redis-safe.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">权限控制</h2>

<ul>
<li><p>指定监听ip（127.0.0.1 或者 某个网段）<br/>
在redis.conf 文件中找到<code>bind 192.168.3.112 127.0.0.1</code>。修改。</p></li>
<li><p>绑定 0.0.0.0 ，用 iptables 来控制访问权限<br/>
如果正常业务中redis服务需要被其他服务器来访问，可以设置iptables策略仅允许指定的ip来访问redis服务。</p></li>
<li><p>设置 redis 访问密码来保证数据安全<br/>
在redis.conf 中找到“requirepass”字段，在后面填上你需要的密码，redis客户端也需要使用密码来访问redis服务。</p></li>
</ul>

<blockquote>
<p>通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器。</p>

<p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令。</p>

<p>如果 AUTH 命令给定的密码 password 和配置文件中的密码相符的话，服务器会返回 OK 并开始接受命令输入。</p>

<p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。<br/>
因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p>
</blockquote>

<ul>
<li>修改redis服务运行账号
请以较低权限账号运行redis服务，且禁用该账号的登录权限。可以限制攻击者往磁盘写入文件，但是redis数据还是能被黑客访问到，或者被黑客恶意删除。</li>
</ul>

<pre><code>groupadd -r redis &amp;&amp; useradd -r -g redis -s /bin/nologin -d /var/lib/redis -M redis

XEC=/usr/local/bin/redis-server
CLIEXEC=/usr/local/bin/redis-cli
PIDFILE=/var/run/redis_6379.pid
CONF=&quot;/etc/redis/6379.conf&quot;
REDISPORT=&quot;6379&quot;
</code></pre>

<h3 id="toc_1">漏洞描述与危害</h3>

<p>对公网开放，且未启用认证的redis服务器。</p>

<p>攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行 flushall 来清空所有数据。</p>

<p>攻击者可通过 eval 执行 lua 代码，或通过数据备份功能往磁盘写入后门文件，如果 redis  以 root 身份运行，黑客可以给 root 账户写入 ssh 公钥文件，直接通过ssh登录受害服务器。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis配置安装最佳实践]]></title>
    <link href="http://www.free-abc.com.cn/14798724609507.html"/>
    <updated>2016-11-23T11:41:00+08:00</updated>
    <id>http://www.free-abc.com.cn/14798724609507.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">介绍</h2>

<p>略</p>

<h2 id="toc_1">安装</h2>

<p>在官网下载的redis3.04源码。</p>

<p>安装参数见：README</p>

<p>源码放在了：/home/gumoon 目录</p>

<p>使用 gumoon 这个账户进行安装的。</p>

<pre><code>tar zxvf redis-3.0.4.tar.gz
cd redis-3.0.4
make
make install  （安装到 /usr/local/bin)
./utils/install_server.sh
</code></pre>

<p>配置：<br/>
Port           : 6379<br/>
Config file    : /etc/redis/6379.conf<br/>
Log file       : /var/log/redis_6379.log<br/>
Data dir       : /var/lib/redis/6379<br/>
Executable     : /usr/local/bin/redis-server<br/>
Cli Executable : /usr/local/bin/redis-cli</p>

<p>启动 redis 服务：<br/>
<code>/etc/init.d/redis_6379 start</code>  </p>

<h2 id="toc_2">配置</h2>

<h3 id="toc_3">创建redis用户</h3>

<pre><code>groupadd -r redis &amp;&amp; useradd -r -g redis -s /sbin/nologin -d /var/lib/redis -M redis
</code></pre>

<h3 id="toc_4">开机启动脚本</h3>

<p>位置：/lib/systemd/system/redis.service</p>

<pre><code>[Unit]
Description=Redis Server
Before=httpd.service
After=network.target

[Service]
Type=simple
EnvironmentFile=-/etc/sysconfig/redis
User=redis
Group=redis
ExecStart=/usr/local/bin/redis-server /etc/redis/6379.conf

[Install]
WantedBy=multi-user.target
</code></pre>

<p>EnvironmentFile 可以配置一些参数，但是，路径不能配置，必须写绝对路径。</p>

<h2 id="toc_5">redis安全</h2>

<p><a href="redis-safe.html">redis安全</a></p>

<h2 id="toc_6">集群</h2>

<ul>
<li>twemproxy代理 （<a href="https://github.com/twitter/twemproxy">https://github.com/twitter/twemproxy</a> ）</li>
</ul>

<h2 id="toc_7">常用命令</h2>

<p>略</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置访问 phpinfo 的域名]]></title>
    <link href="http://www.free-abc.com.cn/php-phpinfo.html"/>
    <updated>2016-11-23T11:33:06+08:00</updated>
    <id>http://www.free-abc.com.cn/php-phpinfo.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">修改 default.conf</h2>

<p>取消注释掉关于php fastcgi那一段。<br/>
修改 root /usr/share/nginx/html 下的<br/>
     <code>fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</code><br/>
重启 nginx 。</p>

<h2 id="toc_1">增加phpinfo.php 文件</h2>

<p>在 /usr/share/nginx/html 文件夹下，增加 phpinfo.php</p>

<h2 id="toc_2">访问验证</h2>

<p><code>http://{IP}/phpinfo.php</code></p>

<h2 id="toc_3">配置关闭访问，防止信息泄露</h2>

<h3 id="toc_4">防止恶意解析</h3>

<p>配置 默认站点指向某个文件夹，设置该文件夹对nginx用户无任何权限。<br/>
然后就会报：403 Forbidden 错误。从而无法访问。</p>

<p>默认 /usr/share/nginx/html 的文件夹权限是 755,改为 chmod 700 html即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php7回滚到php5.6]]></title>
    <link href="http://www.free-abc.com.cn/php7-php56.html"/>
    <updated>2016-11-23T11:29:08+08:00</updated>
    <id>http://www.free-abc.com.cn/php7-php56.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">为什么回滚到php5.6，而不是用最新的php7</h2>

<ol>
<li>memcached的扩展，源码编译安装的时候，php7不提供合适的头文件。</li>
<li>php7还是不稳定版本，生产环境下，暂缓</li>
</ol>

<h2 id="toc_1">如何切换回php5.6</h2>

<ol>
<li>按照文档<a href="php56-install.html">安装好 php5.6</a></li>
<li>修改 /etc/init.d/php-fpm 脚本</li>
<li>修改 /etc/profile 的PATH（可能不需要改）</li>
<li>修改 ~/.zshrc 的PATH</li>
<li>修改 /etc/passwd 的php用户目录（可能不需要改）</li>
<li>编译php扩展，并添加到php.ini 文件中的相应位置开启</li>
<li>kill php-fpm进程</li>
<li>重启 php-fpm 进程</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php 安装 gd 扩展]]></title>
    <link href="http://www.free-abc.com.cn/php-gd.html"/>
    <updated>2016-11-23T11:15:13+08:00</updated>
    <id>http://www.free-abc.com.cn/php-gd.html</id>
    <content type="html"><![CDATA[
<pre><code>yum install libwebp.x86_64 libwebp-devel.x86_64 libwebp-tools.x86_64
yum install libjpeg-turbo-devel.x86_64 libjpeg-turbo-static.x86_64 libjpeg-turbo.x86_64 libjpeg-turbo-utils.x86_64
yum install libpng.x86_64 libpng-devel.x86_64 libpng-static.x86_64
yum install libXpm.x86_64 libXpm-devel.x86_64
yum install freetype-devel.x86_64 freetype.x86_64

./configure --with-freetype-dir=/usr/lib64 --with-jpeg-dir=/usr/lib64
make
make install
</code></pre>

<p>gd扩展应该在编译php的时候编译进去。当然，得先安装图片类库。<br/>
如果gd扩展在编译php的时候就编译进去了，那么，就不需要增加 extension=gd.so 了。</p>

<p>make clean</p>

<p>./configure 后面的选项非常重要，如果没加，就没有那几种图片文件生成支持。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[源码编译安装php5.6.22最佳实践]]></title>
    <link href="http://www.free-abc.com.cn/php56-install.html"/>
    <updated>2016-11-23T11:11:39+08:00</updated>
    <id>http://www.free-abc.com.cn/php56-install.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">准备工作</h2>

<ul>
<li>更新系统 </li>
</ul>

<pre><code>yum update
</code></pre>

<ul>
<li>安装 xml2, 确保有 xml2-config 命令</li>
</ul>

<pre><code>yum install libxml2-devel.x86_64 libxml2.x86_64  
rpm -ql libxml2-devel.x86_64
</code></pre>

<ul>
<li>安装 openssl</li>
</ul>

<pre><code>yum install openssl-devel.x86_64 openssl.x86_64
</code></pre>

<ul>
<li>安装 curl</li>
</ul>

<pre><code>yum install libcurl.x86_64 libcurl-devel.x86_64
</code></pre>

<ul>
<li>安装 libmcrypt</li>
</ul>

<pre><code>yum install libmcrypt.x86_64 libmcrypt-devel.x86_64
</code></pre>

<ul>
<li>安装 gd 需要的lib
<a href="php-gd.html">gd扩展（验证码用的到）</a></li>
</ul>

<h2 id="toc_1">编译</h2>

<ul>
<li>没有 <code>--with-mysql</code> 这种选项了</li>
<li>编译了gd扩展 </li>
</ul>

<pre><code>./configure 
--prefix=/usr/local/php56 
--exec-prefix=/usr/local/php56 
--bindir=/usr/local/php56/bin 
--sbindir=/usr/local/php56/sbin 
--includedir=/usr/local/php56/include 
--libdir=/usr/local/php56/lib/php 
--mandir=/usr/local/php56/php/man 
--with-config-file-path=/usr/local/php56/etc 
--with-mcrypt=/usr/include 
--with-mhash 
--with-openssl 
--with-mysqli=shared,mysqlnd 
--with-pdo-mysql=shared,mysqlnd 
--with-iconv 
--with-zlib 
--enable-zip 
--enable-inline-optimization 
--disable-debug 
--disable-rpath 
--enable-shared 
--enable-xml 
--enable-bcmath 
--enable-shmop 
--enable-sysvsem 
--enable-mbregex 
--enable-mbstring 
--enable-gd-native-ttf 
--enable-pcntl 
--enable-sockets 
--with-xmlrpc 
--enable-soap 
--without-pear 
--with-gettext 
--enable-session 
--with-curl 
--enable-opcache 
--enable-fpm 
--with-fpm-user=nginx 
--with-fpm-group=nginx 
--without-gdbm 
--disable-fileinfo 
--with-freetype-dir=/usr/lib64 
--with-jpeg-dir=/usr/lib64 
--with-gd
</code></pre>

<p>(复制到命令行执行之前，需要去掉换行符）</p>

<pre><code>make &amp;&amp; make install
make clean
</code></pre>

<h2 id="toc_2">php7回滚到php56</h2>

<p><a href="php7-php56.html">php7回滚到php56</a><br/>
如果走这一步的话，下面的步骤有些就不需要再执行了。</p>

<pre><code>cp php.ini-production /usr/local/php56/etc/php.ini
cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
cp /usr/local/php56/etc/php-fpm.conf.default /usr/local/php56/etc/php-fpm.conf
</code></pre>

<h2 id="toc_3">设置path</h2>

<pre><code>vim .zshrc
</code></pre>

<p>修改用户跟目录下的 .zshrc 文件，把 /usr/local/php56/bin 加在path项的前面。</p>

<pre><code>source .zshrc
</code></pre>

<h2 id="toc_4">创建php日志文件目录</h2>

<pre><code>mkdir -p /var/log/php-fpm/ &amp;&amp; mkdir -p /var/run/php-fpm &amp;&amp; cd /var/run/ &amp;&amp; chown -R nginx:nginx php-fpm

mkdir -p /var/lib/php/session

chown -R nginx:nginx /var/lib/php
</code></pre>

<h2 id="toc_5">检查扩展是否都安装了，安装并开启</h2>

<pre><code>cd /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226
</code></pre>

<h2 id="toc_6">配置 php.ini 的 extension及其它</h2>

<pre><code>zend_extension=opcache.so
extension=mysqli.so
extension=pdo_mysql.so
</code></pre>

<p>或者，使用 slat 同步php.ini &amp; php-fpm.conf 文件</p>

<p>启动php-fpm：<br/>
先给 /etc/init.d/php-fpm 增加可执行权限。</p>

<pre><code>/etc/init.d/php-fpm start
</code></pre>

<h2 id="toc_7">配置 memcached 扩展</h2>

<p><a href="php-memcached.html">php5.6 安装 memcached扩展</a></p>

<h2 id="toc_8">配置gd扩展</h2>

<p><a href="php-gd.html">gd扩展（验证码用的到）</a></p>

<h2 id="toc_9">查看phpinfo</h2>

<p>检查扩展安装情况。<br/>
<a href="php-phpinfo.html">配置访问 phpinfo 的域名</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[memcached 最佳实践]]></title>
    <link href="http://www.free-abc.com.cn/14798699605642.html"/>
    <updated>2016-11-23T10:59:20+08:00</updated>
    <id>http://www.free-abc.com.cn/14798699605642.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">介绍</h2>

<ul>
<li>它比memcache好，有加锁机制等</li>
<li>它比redis性能更高</li>
<li>它特别适合于缓存小数据片</li>
<li>在阿里云上使用yum安装memcached。</li>
</ul>

<h2 id="toc_1">与php配合</h2>

<ul>
<li>安装php的memcached扩展后，就可以通过php语言来编写访问memcached服务的脚本了</li>
<li>php的memcached扩展，通过 libmemcached 库来跟memcached服务器交互</li>
<li>php7无法编译memcached扩展。提示头文件找不到。</li>
<li>最后改成使用<a href="php-memcached.html">php5.6 安装 memcached 扩展</a></li>
</ul>

<h2 id="toc_2">安装</h2>

<p>执行：</p>

<pre><code>yum search memcached
</code></pre>

<p>找到合适的版本的memcached，在这之前，需要先配置好更新及时的 yum源（没有专门的源，配置好 epel 源即可）。 </p>

<p>执行：</p>

<pre><code>yum install memcached.x86_64 libmemcached.x86_64 libmemcached-devel.x86_64
</code></pre>

<p>选择：libmemcached.x86_64（php扩展连接memcached服务器时会用到）、 libmemcached-devel.x86_64（php扩展编译时会用到）、 memcached.x86_64、libevent-devel(memcached编译的时候需要，会默认安装)这三个软件包进行安装。 </p>

<h2 id="toc_3">进程挂掉自动重启</h2>

<p>待补充</p>

<h2 id="toc_4">测试memcached</h2>

<pre><code>telnet 127.0.0.1 11211
</code></pre>

<h2 id="toc_5">开机自动启动</h2>

<p>自从centos7以来，系统服务的管理通过 systemd 来管理。 通过yum安装的memcached，默认已经安装了 memcached.service 脚本。 开机自动启动配置： </p>

<pre><code>systemctl enable memcached.service
</code></pre>

<h2 id="toc_6">权限控制</h2>

<p>修改 <code>/lib/systemd/system/memcached.service</code> 增加 <code>-l 127.0.0.1</code> 参数，然后重启即可。 </p>

<pre><code>systemctl daemon-reload
 systemctl restart memcached 
</code></pre>

<p>增加 -l 127.0.0.1 后，ipv6地址的监听就没有了。(ss -ntlp) </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php 安装 memcached 扩展]]></title>
    <link href="http://www.free-abc.com.cn/php-memcached.html"/>
    <updated>2016-11-23T10:55:08+08:00</updated>
    <id>http://www.free-abc.com.cn/php-memcached.html</id>
    <content type="html"><![CDATA[
<ol>
<li>先要安装 memcached 库：</li>
</ol>

<pre><code>yum install libmemcached-devel.x86_64 libmemcached.x86_64
</code></pre>

<ol>
<li>下载</li>
</ol>

<pre><code>wget http://pecl.php.net/get/memcached-2.2.0.tgz
</code></pre>

<ol>
<li>解压缩</li>
</ol>

<pre><code>tar zxvf memcached-2.2.0.tgz
</code></pre>

<ol>
<li>编译</li>
</ol>

<pre><code>/usr/local/php56/bin/phpize (或者 phpize)

./configure --enable-memcached-sasl

make

make install
</code></pre>

<ol>
<li>确认是否更新：</li>
</ol>

<pre><code>stat memcached.so
</code></pre>

<p>6.添加进php.ini</p>

<pre><code>extension=memcached.so
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx最佳实践]]></title>
    <link href="http://www.free-abc.com.cn/14798693795226.html"/>
    <updated>2016-11-23T10:49:39+08:00</updated>
    <id>http://www.free-abc.com.cn/14798693795226.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<p>从 <code>http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code> 下载最新源更新包。</p>

<pre><code>rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm (这个文件从nginx官网下载的) 
yum install nginx （一定先下载上面那个rpm，确保安装最新的nginx稳定版并且进行了包校验）
</code></pre>

<p>检查安装的版本：</p>

<pre><code>nginx -V 
</code></pre>

<p>打开80端口：</p>

<pre><code>firewall-cmd --add-service=http --permanent 
firewall-cmd —reload 
</code></pre>

<p>启动服务：</p>

<pre><code>systemctl enable nginx.service
systemctl start nginx.service
systemctl restart nginx.service

nginx 启动nginx
nginx -s reload 重启nginx
</code></pre>

<p>然后检测是否安装成功。</p>

<h2 id="toc_1">配置</h2>

<ol>
<li>worker_processes auto nginx进程数，建议按照cpu核数来指定。2个4核cpu时计为8. auto 将自动检测cpu核数。</li>
<li>worker_rlimit_nofile 65535; 这个指令是指一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n)与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与 ulimit -n 的值保持一致。 现在在 linux2.6内核下进程最大打开文件数为65535，所以 worker_rlimit_nofile 就相应应该填写65535. 这是因为 nginx 调度时分配请求到进程并不是那么均衡，所以加入填写10240，总并发量达到3-4万时就有进程可能超过10240，这是就会返回502错误。</li>
<li>use epoll; nginx自动选择最高效的连接处理方法。这个不需要指定。</li>
<li>worker_connections number; 每个 worker_process 可以同时打开的最大连接数。理论上每台nginx服务器的最大连接数为 worker_processes*worker_connections。
还有 fastcgi , https 等等</li>
</ol>

<h2 id="toc_2">nginx的高性能指标</h2>

<p>每秒处理请求数1000以上。（SAE每秒处理请求数是5000）<br/>
每个请求的处理时间：100毫秒以下。</p>

<h2 id="toc_3">如何评测</h2>

<pre><code>ab -n 10000 -c 100 http://www.yourdomain.com/
</code></pre>

<h2 id="toc_4">问题排查</h2>

<p>多看日志</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notification.Name]]></title>
    <link href="http://www.free-abc.com.cn/14798309909156.html"/>
    <updated>2016-11-23T00:09:50+08:00</updated>
    <id>http://www.free-abc.com.cn/14798309909156.html</id>
    <content type="html"><![CDATA[
<hr/>

<p>表达的意义：通知名称。</p>

<p>是一个嵌套类型。</p>

<p>该类型是一个结构体。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Key-paths 作为字符串]]></title>
    <link href="http://www.free-abc.com.cn/14794651181650.html"/>
    <updated>2016-11-18T18:31:58+08:00</updated>
    <id>http://www.free-abc.com.cn/14794651181650.html</id>
    <content type="html"><![CDATA[
<p>用 #keyPath() 代替。<br/>
如下：</p>

<pre><code>class Person: NSObject {
  var name: String = &quot;&quot;

  init(name: String) {
    self.name = name
  }
}
let me = Person(name: &quot;Cosmin&quot;)
me.value(forKeyPath: #keyPath(Person.name))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DispatchQueue（异步）]]></title>
    <link href="http://www.free-abc.com.cn/14794647079536.html"/>
    <updated>2016-11-18T18:25:07+08:00</updated>
    <id>http://www.free-abc.com.cn/14794647079536.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>DispatchQueue manages the execution of work items. Each work item submitted to a queue is processed on a pool of threads managed by the system.</p>
</blockquote>

<p>例子：</p>

<pre><code>let queue = DispatchQueue(label: &quot;Swift 3&quot;)
queue.async {
  print(&quot;Swift 3 queue&quot;)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UserDefaults]]></title>
    <link href="http://www.free-abc.com.cn/14794370507786.html"/>
    <updated>2016-11-18T10:44:10+08:00</updated>
    <id>http://www.free-abc.com.cn/14794370507786.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">是什么？</h2>

<p>NSUserDefaults 类的连接。<br/>
提供了一个对接默认系统的编程接口。<br/>
数据存储在 user defaults database。<br/>
数据先存储在内存中，通过周期性的自动调用<code>synchronize()</code>来刷新数据。</p>

<h2 id="toc_1">作用</h2>

<p>存储用户的自定义数据<br/>
如：界面显示哪些部分、文档自动存储策略、默认的启动状态、默认行为</p>

<h2 id="toc_2">可以存储哪些数据</h2>

<p>floats, doubles, integers, Booleans, and URLs.<br/>
支持的对象类型：NSData, NSString, NSNumber, NSDate, NSArray, or NSDictionary. </p>

<p>如果你要存储其他类型的对象，你需要把它归档为 NSData 实例。</p>

<h2 id="toc_3">返回值</h2>

<p>返回值是常量。不可改变。<br/>
即使你存的是一个变量。</p>

<h2 id="toc_4">存储</h2>

<p>默认为每个用户创建自动创建一个数据库。<br/>
目前不支持分 domain 存储数据。需要的话，请使用 <code>CFPreferences</code><br/>
但是，<code>UserDefaults</code> 可以分 domain 读数据。</p>

<p>If you want to track a file by reference but you require explicit control over when resolution occurs, you should take care to write out bookmark data to NSUserDefaults rather than rely on -[NSUserDefaults setURL:forKey:]. This allows you to call +[NSURL URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:] at a time when you know your application will be able to handle the potential I/O or required user interface interactions.</p>

<h2 id="toc_5">沙盒</h2>

<p>不支持访问其它应用的 <code>UserDefaults</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模拟器]]></title>
    <link href="http://www.free-abc.com.cn/14794017400084.html"/>
    <updated>2016-11-18T00:55:40+08:00</updated>
    <id>http://www.free-abc.com.cn/14794017400084.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">目录：</h2>

<p>打印它：<code>print(NSHomeDirectory())</code></p>

<h2 id="toc_1">旋转屏幕报错：</h2>

<blockquote>
<p>if we&#39;re in the real pre-commit handler we can&#39;t actually add any new fences due to CA restriction</p>
</blockquote>

<p>解决办法：</p>

<pre><code>in your Xcode:

Click on your active scheme name right next to the Stop button
Click on Edit Scheme....
in Run (Debug) select the Arguments tab
in Environment Variables click +
add variable: OS_ACTIVITY_MODE = disable
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络访问]]></title>
    <link href="http://www.free-abc.com.cn/14793884482613.html"/>
    <updated>2016-11-17T21:14:08+08:00</updated>
    <id>http://www.free-abc.com.cn/14793884482613.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">错误信息</h2>

<blockquote>
<p>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&#39;s Info.plist file.</p>
</blockquote>

<p>解决办法：<br/>
在Info.plist文件中添加&quot;App Transport SecuritySettings&quot;, Type为&quot;Dictionary&quot;,再添加&quot;Allow Arbitray Loads&quot;, Type 为&quot;Boolean&quot;，“Value”为“YES”即可。</p>

<blockquote>
<p><a href="http://img3.imgtn.bdimg.com/it/u=2489051743,1646771720&amp;fm=21&amp;gp=0.jpg">http://img3.imgtn.bdimg.com/it/u=2489051743,1646771720&amp;fm=21&amp;gp=0.jpg</a><br/>
下载不了。</p>
</blockquote>

<p>解决办法：<br/>
文件名含有特殊字符: &amp; </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Selector]]></title>
    <link href="http://www.free-abc.com.cn/14793813370586.html"/>
    <updated>2016-11-17T19:15:37+08:00</updated>
    <id>http://www.free-abc.com.cn/14793813370586.html</id>
    <content type="html"><![CDATA[
<p>例子：<br/>
<code>NotificationCenter.default.addObserver(self, selector: #selector(downloadImage), name: Notification.Name(&quot;BLDownloadImageNotification&quot;), object: nil)</code></p>

<p>语法：<br/>
<code>#selector(downloadImage)</code><br/>
<code>#selector(self.downloadImage)</code></p>

<p>错误提示：<br/>
<em>unrecognized selector sent to instance</em></p>

]]></content>
  </entry>
  
</feed>
